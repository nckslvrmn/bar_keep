# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: false
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/solid_cache/all/solid_cache.rbi
#
# solid_cache-1.0.7

module SolidCache
  def configuration; end
  def configuration=(val); end
  def executor; end
  def executor=(val); end
  def self.configuration; end
  def self.configuration=(val); end
  def self.executor; end
  def self.executor=(val); end
  def self.railtie_helpers_paths; end
  def self.railtie_namespace; end
  def self.railtie_routes_url_helpers(include_path_helpers = nil); end
  def self.table_name_prefix; end
  def self.use_relative_model_naming?; end
end
class SolidCache::Engine < Rails::Engine
end
class SolidCache::Configuration
  def connects_to; end
  def default_encryption_context_properties; end
  def encrypt; end
  def encrypt?; end
  def encryption_context_properties; end
  def executor; end
  def initialize(store_options: nil, database: nil, databases: nil, connects_to: nil, executor: nil, encrypt: nil, encryption_context_properties: nil, size_estimate_samples: nil); end
  def set_connects_to(database:, databases:, connects_to:); end
  def shard_keys; end
  def sharded?; end
  def size_estimate_samples; end
  def store_options; end
end
module SolidCache::Connections
  def self.from_config(options); end
end
class SolidCache::MaglevHash
  def build_lookup; end
  def build_preferences(node); end
  def initialize(nodes); end
  def lookup; end
  def md5(*args); end
  def node(key); end
  def node_count; end
  def nodes; end
  def quick_hash(key); end
end
class SolidCache::MaglevHash::Preferences
  def initialize(offset, skip); end
  def next_slot; end
  def preferred_free_slot(lookup); end
  def preferred_slots; end
  def rank; end
end
class SolidCache::Store < ActiveSupport::Cache::Store
  def initialize(options = nil); end
  def self.supports_cache_versioning?; end
  def setup!; end
  include SolidCache::Store::Api
end
module SolidCache::Store::Api
  def adjust(name, amount, options); end
  def adjusted_entry(value, amount, options); end
  def cleanup(options = nil); end
  def clear(options = nil); end
  def decrement(name, amount = nil, options = nil); end
  def delete_entry(key, **options); end
  def delete_multi_entries(entries, **options); end
  def deserialize_entry(payload, **); end
  def increment(name, amount = nil, options = nil); end
  def initialize(options = nil); end
  def max_key_bytesize; end
  def normalize_key(key, options); end
  def read_entry(key, **options); end
  def read_multi_entries(names, **options); end
  def read_serialized_entries(keys); end
  def read_serialized_entry(key, **options); end
  def serialize_entries(entries, **options); end
  def serialize_entry(entry, raw: nil, **options); end
  def truncate_key(key); end
  def write_entry(key, entry, raw: nil, unless_exist: nil, **options); end
  def write_multi_entries(entries, expires_in: nil, **options); end
  def write_serialized_entry(key, payload, raw: nil, unless_exist: nil, expires_in: nil, race_condition_ttl: nil, returning: nil, **options); end
end
module SolidCache::Store::Connections
  def connection_names; end
  def connections; end
  def group_by_connection(keys); end
  def initialize(options = nil); end
  def reading_key(key, failsafe:, failsafe_returning: nil, &block); end
  def reading_keys(keys, failsafe:, failsafe_returning: nil); end
  def setup!; end
  def shard_options; end
  def with_connection(name, async: nil, &block); end
  def with_connection_for(key, async: nil, &block); end
  def with_each_connection(async: nil, &block); end
  def writing_all(failsafe:, failsafe_returning: nil, &block); end
  def writing_key(key, failsafe:, failsafe_returning: nil, &block); end
  def writing_keys(entries, failsafe:, failsafe_returning: nil); end
end
module SolidCache::Store::Entries
  def clear_with; end
  def entry_clear; end
  def entry_delete(key); end
  def entry_delete_multi(entries); end
  def entry_lock_and_write(key, &block); end
  def entry_read(key); end
  def entry_read_multi(keys); end
  def entry_write(key, payload); end
  def entry_write_multi(entries); end
  def initialize(options = nil); end
end
module SolidCache::Store::Execution
  def active_record_instrumentation?; end
  def async(&block); end
  def execute(async, &block); end
  def initialize(options = nil); end
  def setup_instrumentation(&block); end
  def wrap_in_rails_executor(&block); end
end
module SolidCache::Store::Expiry
  def expire_later; end
  def expires_per_write; end
  def expiry_batch_size; end
  def expiry_batches(count); end
  def expiry_method; end
  def expiry_queue; end
  def initialize(options = nil); end
  def max_age; end
  def max_entries; end
  def max_size; end
  def track_writes(count); end
end
module SolidCache::Store::Failsafe
  def error_handler; end
  def failsafe(method, returning: nil); end
  def initialize(options = nil); end
end
module SolidCache::Store::Stats
  def connection_stats; end
  def connections_stats; end
  def initialize(options = nil); end
  def stats; end
end
class SolidCache::Connections::Sharded
  def assign(keys); end
  def consistent_hash; end
  def count; end
  def initialize(names); end
  def names; end
  def nodes; end
  def shard_for(key); end
  def with(name, &block); end
  def with_connection_for(key, &block); end
  def with_each(&block); end
end
class SolidCache::Connections::Single
  def assign(keys); end
  def count; end
  def initialize(name); end
  def name; end
  def names; end
  def with(name, &block); end
  def with_connection_for(key, &block); end
  def with_each(&block); end
end
class SolidCache::Connections::Unmanaged
  def assign(keys); end
  def count; end
  def names; end
  def with(name); end
  def with_connection_for(key); end
  def with_each; end
end
class SolidCache::ExpiryJob < ActiveJob::Base
  def perform(count, shard: nil, max_age: nil, max_entries: nil, max_size: nil); end
end
class SolidCache::Record::ActiveRecord_Relation < ActiveRecord::Relation
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Base::GeneratedRelationMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include SolidCache::Record::GeneratedRelationMethods
end
module SolidCache::Record::GeneratedRelationMethods
end
class SolidCache::Record::ActiveRecord_Associations_CollectionProxy < ActiveRecord::Associations::CollectionProxy
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Base::GeneratedRelationMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include SolidCache::Record::GeneratedRelationMethods
end
class SolidCache::Record::ActiveRecord_AssociationRelation < ActiveRecord::AssociationRelation
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Base::GeneratedRelationMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include SolidCache::Record::GeneratedRelationMethods
end
class SolidCache::Record::ActiveRecord_DisableJoinsAssociationRelation < ActiveRecord::DisableJoinsAssociationRelation
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Base::GeneratedRelationMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include SolidCache::Record::GeneratedRelationMethods
end
class SolidCache::Record < ActiveRecord::Base
  def self.__class_attr__validators; end
  def self.__class_attr__validators=(new_value); end
  def self.__class_attr_defined_enums; end
  def self.__class_attr_defined_enums=(new_value); end
  def self.disable_instrumentation(&block); end
  def self.each_shard(&block); end
  def self.with_instrumenter(instrumenter, &block); end
  def self.with_shard(shard, &block); end
  include SolidCache::Record::GeneratedAssociationMethods
  include SolidCache::Record::GeneratedAttributeMethods
end
module SolidCache::Record::GeneratedAttributeMethods
end
module SolidCache::Record::GeneratedAssociationMethods
end
class SolidCache::Entry < SolidCache::Record
  def self.__class_attr__validators; end
  def self.__class_attr__validators=(new_value); end
  def self.__class_attr_defined_enums; end
  def self.__class_attr_defined_enums=(new_value); end
  def self.add_key_hash_and_byte_size(payloads); end
  def self.byte_size_for(payload); end
  def self.clear_delete; end
  def self.clear_truncate; end
  def self.delete_by_key(*keys); end
  def self.estimated_row_overhead; end
  def self.id_range; end
  def self.in_key_hash_range(*args, **); end
  def self.key_hash_for(key); end
  def self.key_hashes_for(keys); end
  def self.largest_byte_sizes(*args, **); end
  def self.lock_and_write(key, &block); end
  def self.read(key); end
  def self.read_multi(keys); end
  def self.select_sql(keys); end
  def self.up_to_byte_size(*args, **); end
  def self.upsert_unique_by; end
  def self.without_query_cache(&block); end
  def self.write(key, value); end
  def self.write_multi(payloads); end
  extend SolidCache::Entry::Expiration::ClassMethods
  extend SolidCache::Entry::Size::ClassMethods
  include SolidCache::Entry::Encryption
  include SolidCache::Entry::GeneratedAssociationMethods
  include SolidCache::Entry::GeneratedAttributeMethods
end
module SolidCache::Entry::Encryption
  extend ActiveSupport::Concern
end
module SolidCache::Entry::Expiration
  extend ActiveSupport::Concern
end
module SolidCache::Entry::Expiration::ClassMethods
  def cache_full?(max_entries:, max_size:); end
  def expire(count, max_age:, max_entries:, max_size:); end
  def expiry_candidate_ids(count, max_age:, max_entries:, max_size:); end
end
module SolidCache::Entry::Size
  extend ActiveSupport::Concern
end
module SolidCache::Entry::Size::ClassMethods
  def estimated_size(samples: nil); end
end
class SolidCache::Entry::ActiveRecord_Relation < ActiveRecord::Relation
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include SolidCache::Entry::GeneratedRelationMethods
  include SolidCache::Record::GeneratedRelationMethods
end
module SolidCache::Entry::GeneratedRelationMethods
  def in_key_hash_range(*, **, &); end
  def largest_byte_sizes(*, **, &); end
  def up_to_byte_size(*, **, &); end
end
class SolidCache::Entry::ActiveRecord_Associations_CollectionProxy < ActiveRecord::Associations::CollectionProxy
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include SolidCache::Entry::GeneratedRelationMethods
  include SolidCache::Record::GeneratedRelationMethods
end
class SolidCache::Entry::ActiveRecord_AssociationRelation < ActiveRecord::AssociationRelation
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include SolidCache::Entry::GeneratedRelationMethods
  include SolidCache::Record::GeneratedRelationMethods
end
class SolidCache::Entry::ActiveRecord_DisableJoinsAssociationRelation < ActiveRecord::DisableJoinsAssociationRelation
  extend ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  include ActiveRecord::Delegation::ClassSpecificRelation
  include SolidCache::Entry::GeneratedRelationMethods
  include SolidCache::Record::GeneratedRelationMethods
end
module SolidCache::Entry::GeneratedAttributeMethods
end
module SolidCache::Entry::GeneratedAssociationMethods
end
class SolidCache::Entry::Size::Estimate
  def exact?; end
  def initialize(samples:); end
  def key_hash_range; end
  def max_records; end
  def non_outlier_estimated_size; end
  def outliers_count; end
  def outliers_cutoff; end
  def outliers_size; end
  def outliers_size_count_and_cutoff; end
  def sample_range; end
  def sample_range_size; end
  def sampled_fraction; end
  def sampled_non_outlier_size; end
  def samples; end
  def size; end
end
class SolidCache::Entry::Size::MovingAverageEstimate
  def estimate; end
  def exact?(*, **, &); end
  def initialize(samples:); end
  def latest_value; end
  def latest_values; end
  def previous_values; end
  def retained_estimates; end
  def retained_estimates_for_target_fraction; end
  def samples; end
  def size; end
  def write_values(values); end
end
